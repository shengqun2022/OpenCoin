{
  "language": "Solidity",
  "sources": {
    "contracts/Exchange.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.24;\nimport \"./Token.sol\";\ncontract Exchange {\n    //收费的账户地址\n    address public feeAccount;\n    uint public feePercent;  //费率\n    address  constant ETHER = address(0);\n\n    struct _Order {\n         uint id;\n         address user;\n         address tokenGet;\n         uint amountGet;\n         address tokenGive;\n         uint  amountGive;\n         uint timestamp;\n    }\n    \n    mapping(address=> mapping(address=>uint)) public tokens;\n    mapping(uint => _Order) public orders;\n    uint public orderCount;\n\n    mapping(uint=> bool) public orderCancel;\n    mapping(uint=> bool) public orderFill;\n\n    event Depost(address token, address user, uint amount, uint blance);\n    event Withdraw(address token, address user, uint amount, uint blance);\n    event Order(uint id,address user,address _tokenGet, uint _amountGet,address _tokenGive,uint _amountGive,uint timestamp);\n    event Cancel(uint id,address user,address _tokenGet, uint _amountGet,address _tokenGive,uint _amountGive,uint timestamp);\n    event Trade(uint id,address user,address _tokenGet, uint _amountGet,address _tokenGive,uint _amountGive,uint timestamp);\n\n    constructor(address _feeAccount, uint _feePercent) {\n        feeAccount = _feeAccount;\n        feePercent = _feePercent;\n    }\n\n    function depositEther () payable public {\n        tokens[ETHER][msg.sender] = tokens[ETHER][msg.sender] + msg.value;\n        emit Depost(ETHER,msg.sender,msg.value,tokens[ETHER][msg.sender]);\n    }\n\n    function depositToken (address _token, uint _amount) public {\n        require(_token!= address(0),'unvalid token');\n        require(Token(_token).transferFrom(msg.sender,address(this),_amount),'trans fail');\n        tokens[_token][msg.sender] = tokens[_token][msg.sender] + _amount;\n        emit Depost(_token,msg.sender,_amount,tokens[_token][msg.sender]);\n    }\n\n    function  withdrawEther (uint _amount) payable public {\n        require(tokens[ETHER][msg.sender] >= _amount,'amount is no enough ') ;\n         tokens[ETHER][msg.sender] = tokens[ETHER][msg.sender] - _amount;\n         payable(msg.sender).transfer(_amount);\n         emit Withdraw(ETHER,msg.sender,_amount,tokens[ETHER][msg.sender]);\n    }\n\n    function  withdrawToken(address _token,uint _amount)  public {\n        require(tokens[_token][msg.sender] >= _amount,'amount is no enough ') ;\n         tokens[_token][msg.sender] = tokens[_token][msg.sender] - _amount;\n         Token(_token).transfer(msg.sender,_amount);\n         emit Withdraw(_token,msg.sender,_amount,tokens[_token][msg.sender]);\n    }\n\n    function balanceOf(address _token,address _user) public view  returns(uint) {\n        return tokens[_token][_user];\n    }\n\n    // makerOrder \n    function markOrder (address _tokenGet, uint _amountGet,address _tokenGive,uint _amountGive) public {\n        orderCount +=1;\n        orders[orderCount] = _Order(orderCount,msg.sender,_tokenGet,_amountGet,_tokenGive,_amountGive,block.timestamp);\n        emit Order(orderCount,msg.sender,_tokenGet,_amountGet,_tokenGive,_amountGive,block.timestamp);\n    }\n\n    function cancelOrder (uint _id) public {\n        _Order memory myorder = orders[_id];\n        require(_id ==myorder.id,'no valid order');\n        orderCancel[_id] = true;\n        emit Cancel(_id, msg.sender,myorder.tokenGet,myorder.amountGet,myorder.tokenGive,myorder.amountGive,block.timestamp);\n    }\n\n    function fillOrder (uint _id) public {\n          _Order memory myorder = orders[_id];\n        require(_id == myorder.id,'no valid order');\n        orderFill[_id] = true;\n    \n       uint feeAmount = myorder.amountGet * (feePercent/100);\n\n        tokens[myorder.tokenGet][msg.sender] = tokens[myorder.tokenGet][msg.sender]- myorder.amountGet;\n        tokens[myorder.tokenGet][myorder.user] = tokens[myorder.tokenGet][myorder.user] + myorder.amountGet;\n\n        tokens[myorder.tokenGet][msg.sender] =  tokens[myorder.tokenGet][msg.sender]  -  feeAmount;\n        tokens[myorder.tokenGet][feeAccount] =  tokens[myorder.tokenGet][feeAccount]  +  feeAmount;\n       \n\n        tokens[myorder.tokenGive][msg.sender] = tokens[myorder.tokenGive][msg.sender] + myorder.amountGive;\n        tokens[myorder.tokenGive][myorder.user] = tokens[myorder.tokenGive][myorder.user]- myorder.amountGive;\n\n\n\n        emit Trade(_id, msg.sender,myorder.tokenGet,myorder.amountGet,myorder.tokenGive,myorder.amountGive,block.timestamp);\n    }\n}"
    },
    "contracts/Token.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.24;\nimport './Utils.sol';\n\ncontract Token is Utils{\n    /* 公共变量 */\n    string public name = ''; //代币名称\n    string public symbol = ''; //代币符号比如'$'\n    uint8 public decimals = 0;  //代币单位\n    uint256 public totalSupply = 10000; //代币总量\n\n    /*记录所有余额的映射*/\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    /* 在区块链上创建一个事件，用以通知客户端*/\n    event Transfer(address indexed from, address indexed to, uint256 value);  //转帐通知事件\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value); //设置允许用户支付最大金额通知\n\n    /* 初始化合约，并且把初始的所有代币都给这合约的创建者\n     * @param tokenName 代币名称\n     * @param tokenSymbol 代币符号\n     * @param decimalsUnits 代币后面的单位，小数点后面多少个0，以太币一样后面是是18个0\n     */\n    constructor(string memory tokenName, string memory tokenSymbol, uint8 decimalsUnits) {\n        // require(bytes(tokenName).length > 0 && bytes(tokenSymbol).length > 0); // validate input\n        name = tokenName;\n        symbol = tokenSymbol;\n        decimals = decimalsUnits;\n        balanceOf[msg.sender] = 10000 * 10 ** decimals;\n    }\n\n    /**\n     * 私有方法从一个帐户发送给另一个帐户代币\n     * @param  _from address 发送代币的地址\n     * @param  _to address 接受代币的地址\n     * @param  _value uint256 接受代币的数量\n     */\n    function _transfer(address _from, address _to, uint256 _value)\n      internal\n      validAddress(_from)\n      validAddress(_to)\n    {\n\n\n      //检查发送者是否拥有足够余额\n      require(balanceOf[_from] >= _value);\n\n      //检查是否溢出\n      require(balanceOf[_to] + _value > balanceOf[_to]);\n\n      //保存数据用于后面的判断\n      uint previousBalances = safeAdd(balanceOf[_from], balanceOf[_to]);\n\n      //从发送者减掉发送额\n      balanceOf[_from] = safeSub(balanceOf[_from], _value);\n\n      //给接收者加上相同的量\n      balanceOf[_to] += safeAdd(balanceOf[_to], _value);\n\n      //通知任何监听该交易的客户端\n      emit Transfer(_from, _to, _value);\n\n      //判断买、卖双方的数据是否和转换前一致\n      assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n\n    }\n\n    /**\n     * 从主帐户合约调用者发送给别人代币\n     * @param  _to address 接受代币的地址\n     * @param  _value uint256 接受代币的数量\n     */\n    function transfer(address _to, uint256 _value)\n      public\n      validAddress(_to)\n      returns (bool)\n    {\n        _transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    /**\n     * 从某个指定的帐户中，向另一个帐户发送代币\n     *\n     * 调用过程，会检查设置的允许最大交易额\n     *\n     * @param  _from address 发送者地址\n     * @param  _to address 接受者地址\n     * @param  _value uint256 要转移的代币数量\n     * @return        是否交易成功\n     */\n    function transferFrom(address _from, address _to, uint256 _value)\n        public\n        validAddress(_from)\n        validAddress(_to)\n        returns (bool)\n    {\n        //检查发送者是否拥有足够余额支出的设置\n        require(_value <= allowance[_from][msg.sender], '-invalid value');   // Check allowance\n\n        allowance[_from][msg.sender] -= safeSub(allowance[_from][msg.sender], _value);\n\n        _transfer(_from, _to, _value);\n\n        return true;\n    }\n\n    /**\n     * 设置帐户允许支付的最大金额\n     *\n     * 一般在智能合约的时候，避免支付过多，造成风险\n     *\n     * @param _spender 帐户地址\n     * @param _value 金额\n     */\n    function approve(address _spender, uint256 _value)\n        public\n        validAddress(_spender)\n        returns (bool success)\n    {\n\n        require(_value == 0 || allowance[msg.sender][_spender] == 0, 'fail valid');\n\n        allowance[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n\n     function allowanceOf(address _add1, address _add2)\n        public view\n        returns (uint256)\n    {\n        return allowance[_add1][_add2];\n      \n    }\n}"
    },
    "contracts/Utils.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.24;\n\n/*\n    Utilities & Common Modifiers\n*/\ncontract Utils {\n    // verifies that an amount is greater than zero\n    modifier greaterThanZero(uint256 _amount) {\n        require(_amount > 0);\n        _;\n    }\n\n    // validates an address - currently only checks that it isn't null\n    modifier validAddress(address _address) {\n        require(_address != address(0));\n        _;\n    }\n\n    // verifies that the address is different than this contract address\n    modifier notThis(address _address) {\n        require(_address != address(this));\n        _;\n    }\n\n    // Overflow protected math functions\n\n    /**\n        @dev returns the sum of _x and _y, asserts if the calculation overflows\n\n        @param _x   value 1\n        @param _y   value 2\n\n        @return sum\n    */\n    function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) {\n        uint256 z = _x + _y;\n        assert(z >= _x);\n        return z;\n    }\n\n    /**\n        @dev returns the difference of _x minus _y, asserts if the subtraction results in a negative number\n\n        @param _x   minuend\n        @param _y   subtrahend\n\n        @return difference\n    */\n    function safeSub(uint256 _x, uint256 _y) internal pure returns (uint256) {\n        assert(_x >= _y);\n        return _x - _y;\n    }\n\n    /**\n        @dev returns the product of multiplying _x by _y, asserts if the calculation overflows\n\n        @param _x   factor 1\n        @param _y   factor 2\n\n        @return product\n    */\n    function safeMul(uint256 _x, uint256 _y) internal pure returns (uint256) {\n        uint256 z = _x * _y;\n        assert(_x == 0 || z / _x == _y);\n        return z;\n    }\n}"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}